package handlers

import (
	"fmt"
	"math/rand"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"

	"my-go-project/models"
)

// handlers/lotto_simple.go
func GetAllLottoASC(c *gin.Context, db *gorm.DB) {
	fmt.Println(">>> HIT GetAllLottoASC") // debug log
	var items []models.Lotto
	if err := db.Model(&models.Lotto{}).
		Order("lotto_id ASC").
		Find(&items).Error; err != nil {
		c.JSON(500, gin.H{"status": "error", "message": err.Error()})
		return
	}
	c.JSON(200, gin.H{
		"status": "success",
		"count":  len(items), // ‡πÉ‡∏ä‡πâ count ‡πÅ‡∏ó‡∏ô page/limit ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏¢‡∏Å‡πÉ‡∏´‡πâ‡∏≠‡∏≠‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÉ‡∏´‡∏°‡πà
		"data":   items,
	})
}


// ‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏•‡∏Ç 6 ‡∏´‡∏•‡∏±‡∏Å‡πÅ‡∏ö‡∏ö‡∏™‡∏ï‡∏£‡∏¥‡∏á ‡πÄ‡∏ä‡πà‡∏ô "042317"
func random6() string {
	return fmt.Sprintf("%06d", rand.Intn(1_000_000))
}

// POST /lotto/seed?count=100
// ‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏•‡∏Ç 6 ‡∏´‡∏•‡∏±‡∏Å "‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥" ‡πÉ‡∏™‡πà‡∏ï‡∏≤‡∏£‡∏≤‡∏á lotto ‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö count (‡∏î‡∏µ‡∏ü‡∏≠‡∏•‡∏ï‡πå 100)
// ‡πÉ‡∏ä‡πâ UNIQUE(lotto_number) ‡∏Å‡∏±‡∏ô‡∏ã‡πâ‡∏≥‡∏£‡∏∞‡∏î‡∏±‡∏ö DB + DoNothing ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏ä‡∏ô
func InsertLotto(c *gin.Context, db *gorm.DB) {
	// seed rand (‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å‡∏Ç‡∏≠‡∏á‡πÇ‡∏õ‡∏£‡πÄ‡∏ã‡∏™‡∏û‡∏≠ ‡πÅ‡∏ï‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ‡∏Å‡πá‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ)
	rand.Seed(time.Now().UnixNano())

	// ‡∏≠‡πà‡∏≤‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
	want := 100
	if v := c.Query("count"); v != "" {
		if n, err := strconv.Atoi(v); err == nil && n > 0 {
			want = n
		}
	}
	if want > 10000 { // ‡∏Å‡∏±‡∏ô‡∏¢‡∏¥‡∏á‡∏´‡∏ô‡∏±‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
		want = 10000
	}

	// ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ auth ‡πÅ‡∏•‡πâ‡∏ß‡∏≠‡∏¢‡∏≤‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏π‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á:
	var createdBy *uint = nil
	// ex:
	// if uid, ok := c.Get("user_id"); ok {
	//     if id, ok2 := uid.(uint); ok2 { createdBy = &id }
	// }

	inserted, attempts := 0, 0
	const maxAttempts = 200

	for inserted < want && attempts < maxAttempts {
		attempts++

		// ‡∏Ç‡∏ô‡∏≤‡∏î batch
		batchSize := want - inserted
		if batchSize > 200 {
			batchSize = 200
		}

		// ‡∏Å‡∏±‡∏ô‡∏ã‡πâ‡∏≥‡πÉ‡∏ô batch ‡∏Å‡πà‡∏≠‡∏ô
		seen := make(map[string]struct{}, batchSize)
		batch := make([]models.Lotto, 0, batchSize)

		for len(batch) < batchSize {
			n := random6()
			if _, dup := seen[n]; dup {
				continue
			}
			seen[n] = struct{}{}
			batch = append(batch, models.Lotto{
				LottoNumber: n,
				Status:      "sell",
				Price:       80,
				CreatedBy:   createdBy,
			})
		}

		// Insert ‡πÇ‡∏î‡∏¢‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏ä‡∏ô (‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ UNIQUE(lotto_number) ‡πÉ‡∏ô DB)
		res := db.
			Clauses(clause.OnConflict{
				Columns:   []clause.Column{{Name: "lotto_number"}},
				DoNothing: true,
			}).
			Create(&batch)

		if res.Error != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"status":  "error",
				"message": "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏•‡∏≠‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡∏µ‡πà‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: " + res.Error.Error(),
			})
			return
		}

		inserted += int(res.RowsAffected)
	}

	if inserted < want {
		c.JSON(http.StatusInternalServerError, gin.H{
			"status":  "error",
			"message": fmt.Sprintf("‡∏™‡∏∏‡πà‡∏°‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏î‡πâ %d ‡∏à‡∏≤‡∏Å %d (‡πÄ‡∏•‡∏Ç‡∏ä‡∏ô‡∏Å‡∏±‡∏ö‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡πà‡∏≤‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ)", inserted, want),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"status":   "success",
		"inserted": inserted,
	})
}

type PreviewUpdateItem struct {
	LottoID        uint   `json:"lotto_id"`
	LottoNumberOld string `json:"lotto_number_old"`
	LottoNumberNew string `json:"lotto_number_new"`
}


// POST /lottos/preview-update?count=100&status=sell
// ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å lotto ‡πÄ‡∏î‡∏¥‡∏° (‡∏ï‡∏≤‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞) ‡∏°‡∏≤ N ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ ‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏•‡∏Ç‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ä‡∏ô DB ‡πÉ‡∏´‡πâ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ (‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å)
// ‡πÄ‡∏û‡∏¥‡πà‡∏° import ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ
// import "strings"

func PreviewUpdateLotto(c *gin.Context, db *gorm.DB) {
	rand.Seed(time.Now().UnixNano())

	// ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
	want := 100
	if v := c.Query("count"); v != "" {
		if n, err := strconv.Atoi(v); err == nil && n > 0 {
			want = n
		}
	}
	if want > 5000 {
		want = 5000
	}

	// ‚úÖ ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ñ‡∏≠‡∏°‡∏°‡∏≤, ‡∏î‡∏µ‡∏ü‡∏≠‡∏•‡∏ï‡πå = ‡∏ó‡∏±‡πâ‡∏á sell ‡πÅ‡∏•‡∏∞ sold
	statusParam := strings.ToLower(strings.TrimSpace(c.DefaultQuery("status", "sell,sold")))
	var statuses []string
	if statusParam != "" {
		for _, p := range strings.Split(statusParam, ",") {
			p = strings.TrimSpace(p)
			if p != "" {
				statuses = append(statuses, p)
			}
		}
	}

	type row struct {
		LottoID     uint
		LottoNumber string
	}

	// ‚úÖ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏ñ‡∏ß‡πÅ‡∏ö‡∏ö‡∏™‡∏∏‡πà‡∏°‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ "‡∏ä‡∏∏‡∏î‡∏ó‡∏µ‡πà" ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏î‡πâ‡∏à‡∏£‡∏¥‡∏á
	var targets []row
	tx := db.Model(&models.Lotto{}).
		Select("lotto_id, lotto_number")
	if len(statuses) > 0 {
		tx = tx.Where("status IN ?", statuses)
	}
	// üëá ‡∏à‡∏∏‡∏î‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç: ‡∏™‡∏∏‡πà‡∏°
	if err := tx.Order("RAND()").Limit(want).Scan(&targets).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
		return
	}
	if len(targets) == 0 {
		c.JSON(http.StatusOK, gin.H{"status": "success", "count": 0, "data": []PreviewUpdateItem{}})
		return
	}

	// ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏•‡∏Ç‡∏ã‡πâ‡∏≥‡πÉ‡∏ô DB
	numberExists := func(n string) (bool, error) {
		var cnt int64
		if err := db.Model(&models.Lotto{}).Where("lotto_number = ?", n).Count(&cnt).Error; err != nil {
			return false, err
		}
		return cnt > 0, nil
	}

	seen := make(map[string]struct{}, want) // ‡∏Å‡∏±‡∏ô‡∏ã‡πâ‡∏≥‡πÉ‡∏ô request
	out := make([]PreviewUpdateItem, 0, len(targets))

	// ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏•‡∏Ç‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏´‡πâ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÅ‡∏ñ‡∏ß
	const maxAttemptsPerItem = 10000
	for _, t := range targets {
		found := false
		for attempt := 0; attempt < maxAttemptsPerItem; attempt++ {
			n := random6()

			// ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡πÄ‡∏•‡∏Ç‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á‡πÅ‡∏ñ‡∏ß
			if n == t.LottoNumber {
				continue
			}
			// ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏™‡∏∏‡πà‡∏°‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô‡πÄ‡∏≠‡∏á‡πÉ‡∏ô request
			if _, dup := seen[n]; dup {
				continue
			}
			// ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏ä‡∏ô‡∏Å‡∏±‡∏ö DB
			ok, err := numberExists(n)
			if err != nil {
				c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
				return
			}
			if ok {
				continue
			}

			seen[n] = struct{}{}
			out = append(out, PreviewUpdateItem{
				LottoID:        t.LottoID,
				LottoNumberOld: t.LottoNumber,
				LottoNumberNew: n,
			})
			found = true
			break
		}
		// ‡∏ñ‡πâ‡∏≤‡πÄ‡∏à‡∏≠‡πÄ‡∏•‡∏Ç‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡πÇ‡∏Ñ‡∏ß‡∏ï‡πâ‡∏≤ attempt ‡∏Å‡πá‡∏Ç‡πâ‡∏≤‡∏°‡πÅ‡∏ñ‡∏ß‡∏ô‡∏µ‡πâ‡πÑ‡∏õ (‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ want)
		if !found {
			continue
		}
	}
		sort.Slice(out, func(i, j int) bool {
			return out[i].LottoID < out[j].LottoID
		})

	// ‡∏Å‡∏±‡∏ô cache ‡∏Ç‡∏≤ client (‡πÄ‡∏ú‡∏∑‡πà‡∏≠ proxy ‡πÅ‡∏õ‡∏•‡∏Å‡πÜ)
	c.Header("Cache-Control", "no-store")

	c.JSON(http.StatusOK, gin.H{
		"status": "success",
		"count":  len(out),
		"data":   out,
	})
}


type UpdateItem struct {
	LottoID     uint   `json:"lotto_id"`
	LottoNumber string `json:"lotto_number"`
}

type BulkUpdateReq struct {
	Items []UpdateItem `json:"items"`
}

func BulkUpdateLottoNumbers(c *gin.Context, db *gorm.DB) {
	var req BulkUpdateReq
	if err := c.ShouldBindJSON(&req); err != nil || len(req.Items) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"status": "error", "message": "invalid payload"})
		return
	}

	// ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡πÄ‡∏•‡∏Ç‡∏ã‡πâ‡∏≥‡πÉ‡∏ô payload ‡πÄ‡∏≠‡∏á‡∏Å‡πà‡∏≠‡∏ô ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏ä‡∏ô UNIQUE ‡πÉ‡∏ô DB
	seen := make(map[string]struct{}, len(req.Items))
	for i := range req.Items {
		n := strings.TrimSpace(req.Items[i].LottoNumber)

		// ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏•‡∏Ç 6 ‡∏´‡∏•‡∏±‡∏Å (‡πÄ‡∏ï‡∏¥‡∏°‡∏®‡∏π‡∏ô‡∏¢‡πå‡∏ã‡πâ‡∏≤‡∏¢) ‡πÅ‡∏•‡∏∞‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏•‡πâ‡∏ß‡∏ô
		if len(n) == 0 {
			c.JSON(http.StatusBadRequest, gin.H{"status": "error", "message": "empty lotto_number in payload"})
			return
		}
		if len(n) > 6 {
			n = n[len(n)-6:] // ‡πÄ‡∏Å‡πá‡∏ö 6 ‡∏ï‡∏±‡∏ß‡∏ó‡πâ‡∏≤‡∏¢‡∏™‡∏∏‡∏î
		}
		// ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô 6 ‡∏´‡∏•‡∏±‡∏Å‡πÄ‡∏™‡∏°‡∏≠
		if _, err := strconv.Atoi(n); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"status": "error", "message": "lotto_number must be numeric"})
			return
		}
		n = fmt.Sprintf("%06s", n)

		req.Items[i].LottoNumber = n

		if _, dup := seen[n]; dup {
			c.JSON(http.StatusBadRequest, gin.H{
				"status":  "error",
				"message": "duplicated lotto_number in request: " + n,
			})
			return
		}
		seen[n] = struct{}{}
	}

	tx := db.Begin()
	if tx.Error != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": tx.Error.Error()})
		return
	}

	// ‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏£‡∏≤‡∏¢‡πÅ‡∏ñ‡∏ß: lotto_number + status='sell'
	for _, it := range req.Items {
		if err := tx.Model(&models.Lotto{}).
			Where("lotto_id = ?", it.LottoID).
			Updates(map[string]any{
				"lotto_number": it.LottoNumber,
				"status":       "sell",
			}).Error; err != nil {
			tx.Rollback()
			c.JSON(http.StatusConflict, gin.H{
				"status":  "error",
				"message": "update failed (maybe duplicate lotto_number): " + err.Error(),
				"failed":  it,
			})
			return
		}
	}

	if err := tx.Commit().Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"status":  "success",
		"updated": len(req.Items),
	})
}

func LottoCount(c *gin.Context, db *gorm.DB) {
	var cnt int64
	if err := db.Model(&models.Lotto{}).Count(&cnt).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"status": "success", "count": cnt})
}